"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Group = require('../BaseClasses/Group');

var AnimatedAttributeSplitter = require('./AnimatedAttributeSplitter');

var Helper = require('../_coreUtils/Helper');

var helper = new Helper();

var ContextAwareIncident = require('./ContextAwareIncident');

var ElementSplitter =
/*#__PURE__*/
function (_Group) {
  _inherits(ElementSplitter, _Group);

  function ElementSplitter(descriptiveIncident, contextData) {
    var _this;

    _classCallCheck(this, ElementSplitter);

    // we make sure the DOMAwareIncident takes the same id as the Descriptive Incident
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ElementSplitter).call(this, {}, {
      id: descriptiveIncident.id
    })); // a property to hold all of the contexts

    _this.contexts = {};
    _this.contexts[contextData.clipId] = contextData.context;
    _this.originalContextKey = contextData.clipId;
    _this.instantiatedCopiesContexts = contextData.instantiatedCopiesContexts;

    _this.setUp(descriptiveIncident, contextData);

    return _this;
  }

  _createClass(ElementSplitter, [{
    key: "setUp",
    value: function setUp(descriptiveIncident, contextData) {
      // the elements of the original context
      var elements = this.originalContext.getElements(descriptiveIncident.selector()); // the elements for each of the copied contexts

      var copiesElements = {};

      for (var contextKey in this.instantiatedCopiesContexts) {
        copiesElements[contextKey] = Array.from(this.instantiatedCopiesContexts[contextKey].rootElement.querySelectorAll(descriptiveIncident.props.selector));
      }

      var totalElements = elements.length;

      for (var i = 0; i < elements.length; i++) {
        var element = elements[i]; // set the mcid of the element on index i of the original context

        var mcid = this._getElementMCID(element); // set the same mcid for the elements of the same context in all of the instantiatedCopiesContexts


        for (var _contextKey in this.instantiatedCopiesContexts) {
          // TODO perfrormance improvement via selecting once elements per context
          this._setElementMCID(this.instantiatedCopiesContexts[_contextKey], this.instantiatedCopiesContexts[_contextKey].getElements(descriptiveIncident.selector())[i], mcid);
        }

        this._createElementIncident(element, descriptiveIncident, contextData, i, totalElements, mcid);
      }
    }
  }, {
    key: "_getElementMCID",
    value: function _getElementMCID(element) {
      var mcid = this.originalContext.getMCID(element);

      if (!mcid) {
        mcid = helper.getAnId(true);
        this.originalContext.setMCID(element, mcid);
      }

      return mcid;
    }
  }, {
    key: "_setElementMCID",
    value: function _setElementMCID(context, element, mcid) {
      var existingMCID = context.getMCID(element);

      if (!existingMCID) {
        context.setMCID(element, mcid);
      }
    }
  }, {
    key: "_createElementIncident",
    value: function _createElementIncident(element, descriptiveIncident, contextData, elementIndex, totalElements, mcid) {
      /* elements splitter might handle either attribute Incidents (that have animatedAttrs) or Incidents
      that do not have animatedAttrs such as MediaPlayback Incidents.
      In the case of an attributed Incident we proceed by creating one AttributeSplitter for each
      while on the case of an non-attribured Incident we go ahead and
      */
      if (Object.prototype.hasOwnProperty.call(descriptiveIncident.attrs, 'animatedAttrs')) {
        var animatedAttributeSplitter = new AnimatedAttributeSplitter(descriptiveIncident, contextData, mcid, contextData.context.getElementSelectorByMCID(mcid));
        this.addChild(animatedAttributeSplitter, 0);
      } else if (Object.prototype.hasOwnProperty.call(descriptiveIncident.attrs, 'keyframes')) {// TODO create a keyframes attribute splitter
      } else {
        var attrsToPass = descriptiveIncident.attrs;

        var propsToPass = _objectSpread({}, descriptiveIncident.props, {
          selector: this.selector
        });

        var constructionIngredients = {
          incidentId: descriptiveIncident.id,
          attrs: attrsToPass,
          props: propsToPass,
          Incident: descriptiveIncident.constructor.Incident,
          plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,
          Channel: descriptiveIncident.constructor.Channel,
          DescriptiveIncident: descriptiveIncident
        };
        var contextAwareIncident = new ContextAwareIncident(constructionIngredients, contextData, mcid, null);
        this.addChild(contextAwareIncident, 0);
      }
    }
  }, {
    key: "originalContext",
    get: function get() {
      return this.contexts[this.originalContextKey];
    }
  }]);

  return ElementSplitter;
}(Group);

module.exports = ElementSplitter;