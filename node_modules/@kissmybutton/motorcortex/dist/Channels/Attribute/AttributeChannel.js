"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Channel = require('../Channel');

var Helper = require('../../_coreUtils/Helper');

var helper = new Helper();

var _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index');

var _sortBy = require('../../../lodash-custom-build/modularize/lodash.sortby/index');

var lanesHandler = require('./LanesHandler');

var AttributeChannel =
/*#__PURE__*/
function (_Channel) {
  _inherits(AttributeChannel, _Channel);

  function AttributeChannel(props) {
    var _this;

    _classCallCheck(this, AttributeChannel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AttributeChannel).call(this, props));
    /*
    comboAttributes are attributes of type object, holding a number of other attributes.
    E.g. CSS "transform" attribute is a combo that holds a number of other attributes such as:
    translateX, translateY, etc. The lanes handler keeps just one lane for the combo attrs
    in an object format keeping the value of each attribute at any given point.
    Combo attributes are passed on the constructor of the Channel in the format:
    props.comboAttributes: {
        transition: ['translateX', 'translateY', ...],
        <something_else>: ['<attrName1>', '<attrName2>', ...]
    }
    */

    _this.comboAttributes = {};
    /**
     * For incidents that do not have animatedAttrs there should be only one lane per element.
     * The attributes Channel will use a default (fake), fixed attribute for this cases so it always ends
     * up with just one lane per element: <element_id>_<this.fixedAttributeName>
     */

    _this.fixedAttributeName = "_";

    if (props.comboAttributes != null) {
      _this.comboAttributes = props.comboAttributes;
    }

    _this.LanesHandler = new lanesHandler({
      comboAttributes: _this.comboAttributes,
      runTimeInfo: _this.runTimeInfo
    }); // this.type = "attributes";

    return _this;
  }

  _createClass(AttributeChannel, [{
    key: "setComboAttributes",
    value: function setComboAttributes(comboAttributes) {
      this.comboAttributes = comboAttributes;
      this.LanesHandler = new lanesHandler({
        comboAttributes: this.comboAttributes
      });
    }
  }, {
    key: "_resize",
    value: function _resize(durationFraction) {
      this.LanesHandler._resize(durationFraction);
    }
    /* *******************************************************
     DECISION METHODS
     ********************************************************/

    /**
     * All of the incidents coming to this method are element-attribute incidents meaning that they only
     * target just one element and also they include just a single attribute on the incident.attrs.animatedAttrs
     * object
     *
     * @param {array} incidents - A collection of Incidents in the form:
     * {
     *  millisecond
     *  incident
     *  id
     * }
     * @param {string} type - can be either "all-or-nothing" (default) or "keep-passing". If type = "all-or-nothing"
     *  the addition passes only if all incidents pass. If type = "keep-passing" the method will still return true
     *  but will also include an errors array on its return and also will only include the success callbacks on
     *  the execute key of its return
     * @returns either:
     *   {
     *       result:true,
     *       execute: // an array of functions that when executed it will add the Incidents on the Channels
     *   }
     *   or
     *   {
     *       result: false,
     *       errors
     *   }
     */

  }, {
    key: "checkAddition",
    value: function checkAddition(incidents) {
      var _this2 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "all-or-nothing";
      var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();
      /* an array where we keep all affected lanes so we can slip on them at the end.
      The format for each affected lane we keep is:
      {
          mcid: mcid,
          attribute: attribute
      }
      */

      var affectedLanes = []; // while the LanesHandlerSanbox adds lane items it makes decisions of which permanent changes should be made to
      // the permanent and pre-existing objects it handles, such as changes on the initial values of existing animations.
      // Because of the fact the LanesSandboxHandler is only there for testing we don't want to execute these changes
      // during checks but still we need to know them on success. For this, the onSuccessActions array holds all executable
      // functions retured by various LanesHandlerSanbox functions so it can execute them on success.

      var onSuccessActions = [];
      var conflicts = [];

      var _loop = function _loop(i) {
        var incidentConflicts = false; // a boolean that keeps the information whether the incident conflicts or not

        var laneItem = incidents[i];
        var incident = laneItem.incident;
        var mcid = incident.mcid;
        var attribute = incident.attribute || _this2.fixedAttributeName;
        LanesHandlerSandbox.laneExists(mcid, attribute); // create the lane if it doesn't exist already

        affectedLanes.push({
          mcid: mcid,
          attribute: attribute
        }); // **** if the lane did exist before the new addition check for conflicts

        var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(laneItem, mcid, attribute); // helper.log(overlappingAnim)

        if (overlappingAnims.length > 0) {
          incidentConflicts = true;
          conflicts.push({
            type: 'unauthorised, overlapping incidents on the same element',
            meta: {
              element_mcid: mcid,
              attribute: attribute,
              incident: laneItem,
              overlappingAnims: overlappingAnims
            }
          });
        }

        if (!incidentConflicts) {
          onSuccessActions.push(function () {
            LanesHandlerSandbox.addElementToLane(mcid, attribute, laneItem.millisecond, incident);

            incident._onGetContextOnce();
          });
        }
      };

      for (var i = 0; i < incidents.length; i++) {
        _loop(i);
      } // end for each incident
      // if we have conflicts and the type = "all-or-nothing"


      if (conflicts.length > 0 && type === "all-or-nothing") {
        return {
          result: false,
          errors: conflicts
        };
      } else {
        // as soon as we want all passing additions to get applied the Lanes Handler will create a callback that will be passed to the result.
        // This callback will apply all passing additions.
        // success message
        var that = this;

        var exec = function exec() {
          for (var i = 0; i < onSuccessActions.length; i++) {
            onSuccessActions[i]();
          }

          that.LanesHandler.applySandboxChanges(LanesHandlerSandbox);
        };

        return {
          result: true,
          errors: conflicts,
          execute: exec
        };
      }
    }
    /**
     * It initially checks if the edit is allowed and if it is it retuns an array of executable functions
     * that apply the change
     * @param {array} incidents - the list of the lane items to edit in an array format [object, object, ...]
     * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents
     * @returns {object} -
     * either:
     {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
     }
     or
     {
         result: false,
         errors: // an array including all the errors / conflicts found on edit
     }
    */

  }, {
    key: "checkEdit",
    value: function checkEdit(incidents, millisecondsDelta) {
      // console.log(incidents);
      var affectedIncidentIds = [];

      for (var i = 0; i < incidents.length; i++) {
        affectedIncidentIds.push(incidents[i].id);
      }

      var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();
      var conflicts = [];
      var affectedLanes = []; // for each of the affectedAnimations

      for (var _i = 0; _i < incidents.length; _i++) {
        var incident = incidents[_i].incident;
        var incidentId = incident.id;
        var mcid = incidents[_i].incident.mcid;
        var attribute = incidents[_i].incident.attribute || this.fixedAttributeName;
        var lane = LanesHandlerSandbox.getLane(mcid, attribute);
        var laneAttrs = {
          mcid: mcid,
          attribute: attribute // check for conflicts and edit lane items millisecond

        };

        for (var k = 0; k < lane.length; k++) {
          if (lane[k].id === incidentId) {
            affectedLanes.push(laneAttrs);
            var affectedAnim = lane[k];
            var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);
            testLaneElement.millisecond += millisecondsDelta;
            testLaneElement.incident = LanesHandlerSandbox.incidentsById._get(testLaneElement.id);
            var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, mcid, attribute, affectedIncidentIds);

            if (overlappingAnims.length > 0) {
              conflicts.push({
                type: 'anauthorised, overlapping animations on the same element',
                meta: {
                  element_mcid: mcid,
                  attribute: attribute,
                  newAnimation: testLaneElement,
                  overlappingAnims: overlappingAnims
                }
              });
            }

            break;
          } // end of if we found the specific animation on the lane's sequence

        } // end of each lane's item

      } // end for each affected animation's id


      if (conflicts.length > 0) {
        return {
          result: false,
          errors: conflicts
        };
      } else {
        var that = this;

        var exec = function exec() {
          that.LanesHandler.updateLane(affectedIncidentIds, millisecondsDelta);
        };

        return {
          result: true,
          execute: exec
        };
      }
    }
    /**
     * @param {array} incidents - [{id, start, end, startDelta}]
     * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in
     *  that case no checks should be actually perfomed nor the projected candidate should be applied directly
     **/

  }, {
    key: "checkResizedIncidents",
    value: function checkResizedIncidents(incidents) {
      var fullChannelResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var excludeIdsFromCheck = [];

      for (var i = 0; i < incidents.length; i++) {
        excludeIdsFromCheck.push(incidents[i].id);
      }

      var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();
      var conflicts = [];
      var affectedLanes = []; // for each of the incidents passed

      for (var _i2 = 0; _i2 < incidents.length; _i2++) {
        // get the ContextAwareIncident
        var incident = this.LanesHandler.incidentsById._get(incidents[_i2].id);

        var mcid = incident.mcid;
        var attribute = incident.attribute || this.fixedAttributeName;
        var lane = LanesHandlerSandbox.getLane(mcid, attribute);
        var laneAttrs = {
          mcid: mcid,
          attribute: attribute
        };
        var testDuration = incidents[_i2].end - incidents[_i2].start; // check for conflicts and edit lane items millisecond

        for (var k = 0; k < lane.length; k++) {
          if (lane[k].id === incidents[_i2].id) {
            affectedLanes.push(laneAttrs);

            if (fullChannelResize === false) {
              var affectedAnim = lane[k];
              var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);
              testLaneElement.millisecond += incidents[_i2].startDelta;
              testLaneElement.incident = LanesHandlerSandbox.incidentsById._get(testLaneElement.id);
              var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, laneAttrs.mcid, laneAttrs.attribute, excludeIdsFromCheck, testDuration);

              if (overlappingAnims.length > 0) {
                conflicts.push({
                  type: 'anauthorised overlapping animations on the same element',
                  meta: {
                    element_mcid: laneAttrs.mcid,
                    attribute: laneAttrs.attribute,
                    newAnimation: testLaneElement,
                    overlappingAnims: overlappingAnims
                  }
                });
              }
            }

            break;
          } // end of if we found the specific animation on the lane's sequence

        } // end of each lane's item

      } // end for each affected animation's id


      if (conflicts.length > 0) {
        return {
          result: false,
          errors: conflicts
        };
      } else {
        var that = this;

        var exec = function exec() {
          // updateLanes (only this time animation by animation as the milliseconds delta is not standard for all)
          // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the
          // success message
          for (var _i3 = 0; _i3 < incidents.length; _i3++) {
            that.LanesHandler.updateLane([incidents[_i3].id], incidents[_i3].startDelta);
          }
        };

        return {
          execute: exec,
          result: true
        };
      }
    }
    /**
     *
     */

  }, {
    key: "checkDelete",
    value: function checkDelete(removedAnimations) {
      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // eslint-disable-line no-unused-vars
      var removedAnimationIds = [];

      for (var i = 0; i < removedAnimations.length; i++) {
        removedAnimationIds.push(removedAnimations[i].id);
      }

      var that = this;

      var exec = function exec() {
        that.LanesHandler.deleteAnimations(removedAnimationIds);
      };

      return {
        result: true,
        execute: exec
      };
    }
    /**
     * This method is responsible for recalculating the scratch values of the first
     * Incident of each of the lanes of the LanesHandler according to the provided
     * context id
     **/

  }, {
    key: "recalcScratchValues",
    value: function recalcScratchValues(contextId) {
      this.LanesHandler.recalcScratchValues(contextId);
    }
    /**
     * Slips to just one lane forwards
     * @param {array} lane - the lane to slip into
     * @param {object} laneData - an object with keys: attribute & mcid
     * @param {int} currentMillisecond - the millisecond the slip starts from
     * @param {int} millisecond - the target millisecond of the slip
     * @param {string} contextId - the contextId of the Incidents to slip
     */

  }, {
    key: "slipIntoLaneForwards",
    value: function slipIntoLaneForwards(lane, laneData, currentMillisecond, millisecond, contextId) {
      var forceReset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      // console.log(lane, currentMillisecond, millisecond);
      var that = this;

      var participatingAnims = _filter(lane, function (laneItem) {
        return laneItem.millisecond + that.incidentsById._get(laneItem.id).duration >= currentMillisecond && laneItem.millisecond + that.incidentsById._get(laneItem.id).duration <= millisecond || // it ends after currentMillisecond and before target millisecond
        that.incidentsById._get(laneItem.id).duration + laneItem.millisecond >= millisecond && laneItem.millisecond <= millisecond; // or it ends after the target millisecond but also starts before it
      });

      if (participatingAnims.length == 0) {
        if (forceReset === true) {
          var firstIncident = this.incidentsById._get(lane[0].id);

          firstIncident.onProgress(0, 0, contextId);
        }

        return true;
      }

      participatingAnims = _sortBy(participatingAnims, [function (laneItem) {
        return laneItem.millisecond;
      }]); // We only care about the last (in chronological order) Incident, as this
      // will define the final value

      var lastIndex = participatingAnims.length - 1;

      var participatingAnim = this.incidentsById._get(participatingAnims[lastIndex].id);

      var startMillisecond = participatingAnims[lastIndex].millisecond; // if the animation ends before the target millisecond

      if (participatingAnim.duration + startMillisecond <= millisecond) {
        // and it's the last one on the row
        participatingAnim.onProgress(1, participatingAnim.duration, contextId);
      } else {
        // slip for the specific element and the specific attribute. Set the Animation as paused or playing a
        // and store this info somewhere
        var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;
        participatingAnim.onProgress(percentageComplete, millisecond - startMillisecond, contextId);
      }
    }
    /**
     * Slips to just one lane backwards
     * @param {array} lane - the lane to slip into
     * @param {object} laneData - an object with keys: attribute & mcid
     * @param {int} currentMillisecond - the millisecond the slip starts from
     * @param {int} millisecond - the target millisecond of the slip
     * @param {string} contextId - the contextId of the Incidents to slip
     */

  }, {
    key: "slipToLaneBackwards",
    value: function slipToLaneBackwards(lane, laneData, currentMillisecond, millisecond, contextId) {
      var forceReset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      // we take all Animations that are either currently running or
      // they end after the destination point
      // helper.log('<------');
      var that = this;

      var participatingAnims = _filter(lane, function (laneItem) {
        var laneItemEnd = that.incidentsById._get(laneItem.id).duration + laneItem.millisecond;
        return laneItemEnd <= millisecond && laneItemEnd >= currentMillisecond || // they end in the hot area
        laneItem.millisecond >= currentMillisecond && laneItem.millisecond <= millisecond || // they start in the hot area
        laneItem.millisecond < currentMillisecond && laneItemEnd > millisecond; // they overlap the hot area
      }); // let participatingAnims = _filter(lane, laneItem => {
      //     const laneItemEnd = that.incidentsById._get(laneItem.id).duration + laneItem.millisecond;
      //     return (
      //         (laneItemEnd >= millisecond && laneItemEnd <= currentMillisecond) || // they end in the hot area
      //         (laneItem.millisecond >= millisecond && laneItem.millisecond <= currentMillisecond) // they start in the hot area
      //     ); // they overlap the hot area
      // });


      if (participatingAnims.length == 0) {
        if (participatingAnims.length == 0) {
          if (forceReset === true) {
            var firstIncident = this.incidentsById._get(lane[lane.length - 1].id);

            firstIncident.onProgress(1, firstIncident.duration, contextId);
          }

          return true;
        }

        return true;
      }

      participatingAnims = _sortBy(participatingAnims, [function (laneItem) {
        return laneItem.millisecond;
      }]); // We only care about the first (in chronological order) Incident, as this
      // will define the final value of the backwards move

      var lastIndex = 0;

      var participatingAnim = this.incidentsById._get(participatingAnims[lastIndex].id);

      var startMillisecond = participatingAnims[lastIndex].millisecond; // if the animation starts after the target millisecond

      if (startMillisecond >= millisecond) {
        participatingAnim.onProgress(0, 0, contextId);
      } else {
        // slip for the specific element and the specific attribute. Set the Animation as paused or playing a
        // and store this info somewhere
        var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;
        participatingAnim.onProgress(percentageComplete, millisecond - startMillisecond, contextId);
      }
    }
    /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     @param {sring} contextId - the context id to "move"
     @param {boolean} forceReset - set to true if status recalc is needed after edit
     */

  }, {
    key: "moveTo",
    value: function moveTo(from, to, contextId) {
      var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      // step 1: iterate through all lanes
      var laneKeys = this.lanes._keys();

      for (var i = 0; i < laneKeys.length; i++) {
        var laneid = laneKeys[i];

        var lane = this.lanes._get(laneid);

        var laneData = helper.getMCIDandAttrOutOfLaneKey(laneid);

        if (from <= to) {
          this.slipIntoLaneForwards(lane, laneData, from, to, contextId, forceReset);
        } else if (from > to) {
          this.slipToLaneBackwards(lane, laneData, from, to, contextId, forceReset);
        }
      }
    }
  }, {
    key: "lanes",
    get: function get() {
      return this.LanesHandler.lanes;
    }
  }, {
    key: "incidentsById",
    get: function get() {
      return this.LanesHandler.incidentsById;
    }
  }], [{
    key: "type",
    get: function get() {
      return "attributes";
    }
  }]);

  return AttributeChannel;
}(Channel);

module.exports = AttributeChannel;