function compareObjects(obj1, obj2) {
    for (let key in obj1) {
        if (obj1[key] !== obj2[key]) {
            return false;
        }
    }
    return true;
}

class Tester {
    /**
     * @param {object} expected: the expected structure / format of the descriptive
     *  tree. In this form:
     * {
     *      id: <string>
     *      children: {
     *          childrenId: {
     *              id: <string>
     *              position: <int>
     *              children: ...
     *          }, ...
     *      }
     * }
     *
     **/
    testTree(expected, actual) {
        let errors = [];
        if (expected.id !== actual.id) {
            errors.push({
                type: 'invalid id',
                expected: expected.id,
                actual: actual.id,
                expectedObject: expected,
                actualObject: actual
            });
        }

        if (expected.hasOwnProperty('duration')) {
            if (expected.duration !== actual.duration) {
                errors.push({
                    type: 'different duration',
                    expected: expected.duration,
                    actual: actual.duration,
                    expectedObject: expected,
                    actualObject: actual
                });
            }
        }

        // check the number of incidents
        if (expected.hasOwnProperty('children')) {
            if (Object.keys(expected.children).length !== Object.keys(actual.children).length) {
                errors.push({
                    type: 'TREE: different number of children',
                    expected: Object.keys(expected.children).length,
                    actual: Object.keys(actual.children).length,
                    expectedObject: expected,
                    actualObject: actual
                });
            }

            for (let key in expected.children) {
                if (!actual.children.hasOwnProperty(key)) {
                    errors.push({
                        type: 'TREE: missing child key from children of actual',
                        expected: key,
                        actual: 'not present',
                        expectedObject: expected,
                        actualObject: actual
                    });
                }
                else {
                    if (expected.children[key].position !== actual.children[key].position) {
                        errors.push({
                            type: 'TREE: wrong position of child',
                            expected: expected.children[key].position,
                            actual: actual.children[key].position,
                            expectedObject: expected,
                            actualObject: actual
                        });
                    }
                    errors = errors.concat(this.testTree(expected.children[key], actual.children[key].leaf));
                }
            }
        }
        return errors;
    }

    /**
     * @param {object} expected: The expected lanes in the following form:
     * {
     *      <laneid>: [
     *          {
     *              id: <string> ~ the incident id
     *              millisecond: <int>
     *              initialValue: <any>
     *          }
     *      ]
     * }
     *
     * @param {object} incidentsById: the incidentsById object of the LanesHanlder
     *  to be used for fetching the initial attributes of each Incident
     **/
    testLanes(expected, actual, incidentsById) {
        actual = actual.realArray;
        let errors = [];
        if (Object.keys(expected).length !== Object.keys(actual).length) {
            errors.push({
                type: 'LANES: wrong lanes number',
                expected: Object.keys(expected).length,
                actual: Object.keys(actual).length,
                expectedObject: expected,
                actualObject: actual
            });
        }

        for (let laneKey in expected) {
            if (!actual.hasOwnProperty(laneKey)) {
                errors.push({
                    type: 'LANES: missing laneKey',
                    expected: laneKey,
                    actual: 'not present',
                    expectedObject: expected,
                    actualObject: actual
                });
            }
            else if (expected[laneKey].length !== actual[laneKey].length) {
                errors.push({
                    type: `LANES: wrong lanes items number on lane ${laneKey}`,
                    expected: expected[laneKey].length,
                    actual: actual[laneKey].length,
                    expectedObject: expected[laneKey],
                    actualObject: actual[laneKey]
                });
            }
            else {
                for (let i = 0; i < expected[laneKey].length; i++) {
                    const expectedLaneItem = expected[laneKey][i];
                    const actualLaneItem = actual[laneKey][i];

                    let incidentPresent = true;
                    if (!incidentsById.realArray.hasOwnProperty(expectedLaneItem.id)) {
                        errors.push({
                            type: `LANES: missing Incident on incidentsById map`,
                            expected: expectedLaneItem.id,
                            actual: 'not present',
                            actualObject: incidentsById
                        });
                        incidentPresent = false;
                    }

                    if (expectedLaneItem.millisecond !== actualLaneItem.millisecond) {
                        errors.push({
                            type: `LANES: millisecond missmatch on lane item`,
                            expected: expectedLaneItem.millisecond,
                            actual: actualLaneItem.millisecond,
                            expectedObject: expectedLaneItem,
                            actualObject: actualLaneItem
                        });
                    }
                    if (expectedLaneItem.id !== actualLaneItem.id) {
                        errors.push({
                            type: `LANES: id missmatch on lane item`,
                            expected: expectedLaneItem.id,
                            actual: actualLaneItem.id,
                            expectedObject: expectedLaneItem,
                            actualObject: actualLaneItem
                        });
                    }
                    if (incidentPresent) {
                        // console.log(Object.keys(incidentsById.realArray));
                        // console.log(expectedLaneItem.id);
                        const incident = incidentsById._get(expectedLaneItem.id);

                        if (typeof expectedLaneItem.initialValue === "object") {
                            if (!compareObjects(expectedLaneItem.initialValue, incident.initialValue)) {
                                errors.push({
                                    type: `LANES: compo initial value missmatch`,
                                    expected: expectedLaneItem.initialValue,
                                    actual: incident.initialValue,
                                    expectedObject: expectedLaneItem,
                                    actualObject: actualLaneItem
                                });
                            }
                        }
                        else {
                            if (expectedLaneItem.initialValue !== incident.initialValue) {
                                errors.push({
                                    type: `LANES: initial value missmatch`,
                                    expected: expectedLaneItem.initialValue,
                                    actual: incident.initialValue,
                                    expectedObject: expectedLaneItem,
                                    actualObject: actualLaneItem
                                });
                            }
                        }

                        if (expectedLaneItem.hasOwnProperty('targetValue')) {
                            if (typeof expectedLaneItem.targetValue === "object") {
                                if (!compareObjects(expectedLaneItem.targetValue, incident.animatedAttributeValue)) {
                                    errors.push({
                                        type: `LANES: compo targetValue missmatch`,
                                        expected: expectedLaneItem.targetValue,
                                        actual: incident.animatedAttributeValue,
                                        expectedObject: expectedLaneItem,
                                        actualObject: actualLaneItem
                                    });
                                }
                            }
                            else {
                                if (expectedLaneItem.targetValue !== incident.animatedAttributeValue) {
                                    errors.push({
                                        type: `LANES: targetValue value missmatch`,
                                        expected: expectedLaneItem.targetValue,
                                        actual: incident.animatedAttributeValue,
                                        expectedObject: expectedLaneItem,
                                        actualObject: actualLaneItem
                                    });
                                }
                            }
                        }

                    }
                }
            }
        }
        return errors;
    }

    /**
     * @param {array} expected - in the form of:
     * [{
     *      id
     *      millisecond
     * }, ...]
     * @param {array} actual - in the form of:
     * [{
     *      id
     *      millisecond
     * }, ...]
     **/
    testClipLanes(expected, actual) {
        const errors = [];

        if (expected.length != actual.length) {
            errors.push({
                type: `CLIP LANES: different size of clip lane items`,
                expected: expected.length,
                actual: actual.length,
                expectedLane: expected,
                actualLane: actual
            });
            return errors;
        }

        for (let i = 0; i < expected.length; i++) {
            if (expected[i].id !== actual[i].id) {
                errors.push({
                    type: `CLIP LANES: invalid id of clip lane item`,
                    expected: expected[i].id,
                    actual: actual[i].id,
                    expectedLaneItem: expected[i],
                    actualLaneItem: actual[i]
                })
            }
            if (expected[i].millisecond !== actual[i].millisecond) {
                errors.push({
                    type: `CLIP LANES: invalid millisecond of clip lane item`,
                    expected: expected[i].millisecond,
                    actual: actual[i].millisecond,
                    expectedLaneItem: expected[i],
                    actualLaneItem: actual[i]
                })
            }
        }
        return errors;
    }
}

module.exports = Tester;
