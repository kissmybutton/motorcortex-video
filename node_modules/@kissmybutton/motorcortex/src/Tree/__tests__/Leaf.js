import Leaf from '../Leaf';
import Node from '../Node';
import { _DIRECTIONS } from '../_CONST';

const plainLeaf = new Leaf({ id: 'plain-leaf' });
const node = new Node();
class HandlerLeaf extends Leaf {
  handleTestMessage(target, payload) {
    if (payload === 1 && target === 'foo-target') {
      return true;
    }

    return this.bypass();
  }
}
const handlerLeaf = new HandlerLeaf({ duration: 1000 });

test('should generate an id if it is not provided on the props', () => {
  expect(handlerLeaf.id).toHaveLength(18);
});

test('should return the failed payload for _UP messages when it does not belong to a tree and selfExecute=true', () => {
  expect(
    plainLeaf.putMessageOnPipe('foo', {}, 'foo-target', { selfExecute: true, direction: _DIRECTIONS._UP })
  ).toEqual({
    response: false,
    responder: null
  });
});

test('should return an empty payload for _DOWN messages when it does not belong to a tree and selfExecute=true', () => {
  expect(
    plainLeaf.putMessageOnPipe('foo', {}, 'foo-target', { selfExecute: true, direction: _DIRECTIONS._DOWN })
  ).toEqual([]);
});

test('should return the failed payload for _UP messages when it does not belong to a tree and selfExecute=false', () => {
  expect(
    plainLeaf.putMessageOnPipe('foo', {}, 'foo-target', { selfExecute: true, direction: _DIRECTIONS._UP })
  ).toEqual({
    response: false,
    responder: null
  });
});

test('should return an empty array for _DOWN messages when it does not belong to a tree and selfExecute=false', () => {
  expect(
    plainLeaf.putMessageOnPipe('foo', {}, 'foo-target', { selfExecute: true, direction: _DIRECTIONS._DOWN })
  ).toEqual([]);
});

test('should return true for _UP messages for a message it (conditionally) handles and selfExecute=true', () => {
  const res = handlerLeaf.putMessageOnPipe('testMessage', 1, 'foo-target', {
    selfExecute: true,
    direction: _DIRECTIONS._UP
  });
  expect(res.responder).toEqual(handlerLeaf);
  expect(res.response).toBe(true);
});

test('should return the failed payload for _UP messages for a message that it (conditionally) does not hanlde and selfExecute=true', () => {
  const res = handlerLeaf.putMessageOnPipe('testMessage', 0, 'foo-target', {
    selfExecute: true,
    direction: _DIRECTIONS._UP
  });
  expect(res).toEqual({
    response: false,
    responder: null
  });
});

test('should return a response array for _DOWN messages for a message it (conditionally) handles and selfExecute=true', () => {
  const res = handlerLeaf.putMessageOnPipe('testMessage', 1, 'foo-target', {
    selfExecute: true,
    direction: _DIRECTIONS._DOWN
  });
  expect(res).toHaveLength(1);
  expect(res[0].responder).toEqual(handlerLeaf);
  expect(res[0].response).toBe(true);
});

test('should return an empty array for _DOWN messages for a message that it (conditionally) does not hanlde and selfExecute=true', () => {
  const res = handlerLeaf.putMessageOnPipe('testMessage', 0, 'foo-target', {
    selfExecute: true,
    direction: _DIRECTIONS._DOWN
  });
  expect(res).toEqual([]);
});

test('should return the failed payload for _UP messages for a message that it (conditionally) hanldes when selfExecute=false', () => {
  const res = handlerLeaf.putMessageOnPipe('testMessage', 1, 'foo-target', {
    selfExecute: false,
    direction: _DIRECTIONS._UP
  });
  expect(res).toEqual({
    response: false,
    responder: null
  });
});

test('should return an empty array for _DOWN messages for a message that it (conditionally) hanldes but selfExecute=false', () => {
  const res = handlerLeaf.putMessageOnPipe('testMessage', 1, 'foo-target', {
    selfExecute: false,
    direction: _DIRECTIONS._DOWN
  });
  expect(res).toEqual([]);
});

test('should assign its parent when added to a Node', () => {
  node.addChild(plainLeaf, 2000);
  expect(plainLeaf.parentNode).toBe(node);
  expect(plainLeaf.hasParent).toBe(true);
});

test('should release its parent when removed from a Node', () => {
  node.removeChild(plainLeaf.id);
  expect(plainLeaf.parentNode).toBe(null);
  expect(plainLeaf.hasParent).toBe(false);
});

test('A single Node should return 0 positionOnPyramidion', ()=>{
  const tmpNode = new Node();
  expect(tmpNode.positionOnPyramidion).toBe(0);
});

test('A Leaf positioned directly on a Node should return its position on positionOnPyramidion', ()=>{
  const tmpNode = new Node();
  const tmpLeaf = new Leaf({ id: 'tmp-leaf' });
  tmpNode.addChild(tmpLeaf, 2000);
  expect(tmpLeaf.positionOnPyramidion).toBe(2000);
});

test('A second layer Leaf positioned on a Node should return its position on positionOnPyramidion', ()=>{
  const tmpNode = new Node();
  const tmpNode2 = new Node();
  const tmpLeaf = new Leaf({ id: 'tmp-leaf' });
  tmpNode.addChild(tmpLeaf, 2000);
  tmpNode2.addChild(tmpNode, 1500);
  expect(tmpLeaf.positionOnPyramidion).toBe(3500);
  expect(tmpNode.positionOnPyramidion).toBe(1500);
  expect(tmpNode2.positionOnPyramidion).toBe(0);
});