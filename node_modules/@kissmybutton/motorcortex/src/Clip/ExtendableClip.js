const Helper = require('../_coreUtils/Helper');
const helper = new Helper();
const Group = require('../BaseClasses/Group');
const selfContainedIncidentsNpmName = '@kissmybutton/self-contained-incidents'; // TODO remove this
const _TREECONST = require('../Tree/_CONST');


class ExtendableClip extends Group {
    /**
     * @param {object} props - an object that should contain all of the following keys:
     * - html (the html template to render)
     * - css (the css template of the isolated tree)
     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)
     * - host (an Element object that will host the isolated tree)
     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)
     * - type (optional, defaults to "iframe") the type of the Clip. It can be one of the:
     *  - iframe
     *  - plain
     */
    constructor(attrs, props) {
        super(attrs, props);

        this.attrs = attrs;
        this.props = props;

        this.isTheClip = true;

        this.blockingWaitings = {};

        /**
         * The cnannels attribute holds a list of all intantiated Channels of the Incidents belonging to the clip
         * this attribute is only valuable when the Group becomes the Clip
         * The format of the attribute is:
         *  key-value pairs in the manner:
         * <mc_plugin_npm_name>: Channel object
         */
        this.instantiatedChannels = {};

        this.isHostedClip = true;

        /**
         * The instantiatedCopiesContexts is a key-value pairs colleciton holding the
         * contexts of all instantiated ClipCopies
         **/
        this.instantiatedCopiesContexts = {};

        this.onClipInitialise();

        this.runTimeInfo = this.props.runTimeInfo;

        this.durationSubs = [];

        // the audioClip property defines wether the Clip is Audio or not. Defaults to false
        // and should be overiten to true on Audio Clip
        this.audioClip = false;

        this.contextReady = true;
    }


    onClipInitialise() {
        // called when group gets initialised
    }

    contextLoading() {
        this.contextReady = false;
    }

    contextLoaded() {
        this.contextReady = true;
        this.unblock();
    }

    /**
     * This method is been called when a new ClipCopy enters the real tree successfully.
     * @param {object} contextData - keys: clipId, context
     **/
    addContext(contextData) {
        this.instantiatedCopiesContexts[contextData.clipId] = contextData.context;
        contextData.instantiatedCopiesContexts = this.instantiatedCopiesContexts;
        const res = this.putMessageOnPipe('addContext', contextData, {}, { selfExecute: false, direction: _TREECONST._DIRECTIONS._DOWN });

        // if the added context is the first one to enter the realClip we must
        // recalculate the scratch values of all of our first Incidents on our instantiatedChannels
        if (Object.keys(this.instantiatedCopiesContexts).length === 1) { // if it is the first one to be added
            for (let key in this.instantiatedChannels) {
                this.instantiatedChannels[key].recalcScratchValues(contextData.clipId);
            }
            // also we store this non fragmented context on our context so it can be
            // used on Incidents addition for calculating scratch values
            this.context.nonFragmentedContext = contextData.context;
        }

        return res;
    }

    /*
    ExtendableClip (as its name implies) is a Class that should be extended by
    any specific kind of Clip, such as Fragmented or SCGroup. This method must
    be overitten by the new Classes. This definition here is just for reference / help
    purposes
    */
    exportConstructionArguments() {
        return {
            attrs: this.attrs,
            props: this.props
        }
    }

    /**
     * completely resizes the Clip without any checks
     */
    _resize(durationFraction) {
        for (let key in this.instantiatedChannels) {
            this.instantiatedChannels[key]._resize(durationFraction);
        }
        this.setNewDuration(this.duration * durationFraction);
        for (let i = 0; i < this.durationSubs.length; i++) {
            this.durationSubs[i](this.duration);
        }
    }

    /*********************************************************
    Editing commands input methods
    *********************************************************/
    /**
     * This command comes form the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  incident: the Descriptive Incident to be added
     *  millisecond: the millisecond to add it
     *  parentGroupId: the id of the Group to which we want to the Incident to
     * }
     */
    addIncident(payload) {
        const candidates = this.putMessageOnPipe('addIncident', {
                incident: payload.incident,
                millisecond: payload.millisecond,
                parentGroupId: payload.parentGroupId,
                contextData: {
                    clipId: this.id,
                    context: this.context,
                    instantiatedCopiesContexts: this.instantiatedCopiesContexts
                },
                audio: this.audioClip
            },
            payload.parentGroupId, { selfExecute: true, direction: _TREECONST._DIRECTIONS._DOWN });
        // concatenate candidates
        // console.log(candidates);

        const totalIncidentsByPlugin = {};
        for (let i = 0; i < candidates.length; i++) {
            const incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);
            for (let pluginName in incidentsByPlugin) {
                if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
                    totalIncidentsByPlugin[pluginName] = [];
                }
                totalIncidentsByPlugin[pluginName].push(...incidentsByPlugin[pluginName]);
            }
        }
        // console.log(totalIncidentsByPlugin);
        const res = this.checkAddition(totalIncidentsByPlugin);
        if (res.result === true) {
            const successCallback = () => {
                res.execute();

                // up to that point the only context Incident that has been initialised on the
                // ContextAwareIncidents of the candidates is the original context of the
                // ExtendableClip.
                for (let i = 0; i < candidates.length; i++) {
                    candidates[i].responder.addChild(candidates[i].response, payload.millisecond);

                    // recalculate duration the groups that we added
                    // the incidents to along with their parents
                    candidates[i].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });

                    // we also need to add every existing (copied) context to the ContextAwareIncidents
                    // created on the candidates process
                    for (let contextKey in this.instantiatedCopiesContexts) {
                        candidates[i].responder.putMessageOnPipe('addContext', {
                                clipId: contextKey,
                                context: this.instantiatedCopiesContexts[contextKey]
                            },
                            'ContextAwareIncidents', { selfExecute: false, direction: _TREECONST._DIRECTIONS._DOWN });
                    }
                }
            }
            return {
                result: true,
                execute: successCallback
            }
        }
        return res;
    }


    // *******************************************************
    // INCIDENTS MANAGEMENT METHODS
    // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS
    // A "TRANSPARENT GROUP"

    /**
     * The method returns either:
        {
            result:true,
            execute: // an array of functions that when executed it will add the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkAddition(incidentsById, type = "all-or-nothing") {
        // prepare the return payload
        let toReturnResult = true;
        let toReturnErrors = [];
        let toReturnExecutables = [];

        // for each key of the incidentsById object perform the check
        for (let key in incidentsById) {
            // if the clip had no channel instantiated for the specific key (plugin id) yet create it
            if (!Object.prototype.hasOwnProperty.call(this.instantiatedChannels, key)) {
                // intstantiate the channel of the plugin by using the reference to the class definition stored on
                // the very first incident of the array
                // console.log(incidentsById[key][0].incident.plugin_channel_class);
                this.instantiatedChannels[key] = new incidentsById[key][0].incident.plugin_channel_class({
                    runTimeInfo: this.runTimeInfo,
                    context: this.context,
                    subscribe: this.props.subscribe // all channels can subscribe to state or current millisecond changes
                });
            }

            // perform the check
            const pluginResult = this.instantiatedChannels[key].addIncidents(incidentsById[key], type);
            toReturnResult = toReturnResult && pluginResult.result;
            if (pluginResult.result === false) {
                toReturnErrors = toReturnErrors.concat(pluginResult.errors);
            }
            else {
                toReturnExecutables.push(pluginResult.execute);
            }
        } // enf of iteration on the incidentsById keys

        const toReturnExecute = function () {
            for (let i = 0; i < toReturnExecutables.length; i++) {
                toReturnExecutables[i]();
            }
        }

        const additionResult = {
            result: toReturnResult,
            errors: toReturnErrors,
            execute: toReturnExecute
        }
        return additionResult;
    }


    /**
     * This command comes form the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  incident: the Descriptive Incident to be repositioned
     *  millisecond: the new millisecond to put it
     *  parentGroupId: the id of the
     * }
     */
    moveIncident(payload) {
        const candidates = this.putMessageOnPipe('moveIncident', {
                incidentId: payload.id,
                millisecond: payload.millisecond,
                parentGroupId: payload.parentGroupId,
                contextData: {
                    clipId: this.id,
                    context: this.context
                },
                audio: this.audioClip
            },
            payload.parentGroupId, { selfExecute: true, direction: _TREECONST._DIRECTIONS._DOWN });

        const totalIncidentsByPlugin = {};
        for (let i = 0; i < candidates.length; i++) {
            const incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);
            for (let pluginName in incidentsByPlugin) {
                if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
                    totalIncidentsByPlugin[pluginName] = [];
                }
                totalIncidentsByPlugin[pluginName].push(...incidentsByPlugin[pluginName]);
            }
        }

        const res = this.checkMove(totalIncidentsByPlugin, payload.positionDelta);
        if (res.result === true) {
            const successCallback = () => {
                res.execute();
                for (let i = 0; i < candidates.length; i++) {
                    candidates[i].responder.editPosition(candidates[i].response.id, payload.millisecond);

                    // recalculate duration the groups that we added
                    // the incidents to along with their parents
                    candidates[i].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
                }
            }
            return {
                result: true,
                execute: successCallback
            }
        }
        return res;
    }

    /**
     * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)
     * is valid and accepted, according to the rules defined on the channels.
     * The method boobles up until it reaches the Clip.
     * @param {object} incident - the incident to edit
     * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time
     The method should return either:
        {
            result:true,
            execute: // an array of functions that when executed it will edit the Incidents on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkMove(incidentsById, millisecondsDelta) {
        // prepare the return payload
        let toReturnResult = true;
        let toReturnErrors = [];
        let toReturnExecutables = [];

        // for each key of the incidentsById object perform the check
        for (let key in incidentsById) {
            // perform the check
            const pluginResult = this.instantiatedChannels[key].editIncidents(incidentsById[key], millisecondsDelta);
            toReturnResult = toReturnResult && pluginResult.result;
            if (pluginResult.result === false) {
                toReturnErrors = toReturnErrors.concat(pluginResult.errors);
            }
            else {
                toReturnExecutables.push(pluginResult.execute);
            }
        } // enf of iteration on the incidentsById keys

        const toReturnExecute = function () {
            for (let i = 0; i < toReturnExecutables.length; i++) {
                toReturnExecutables[i]();
            }
        }

        const editResult = {
            result: toReturnResult,
            errors: toReturnErrors,
            execute: toReturnExecute
        }
        return editResult;
    }

    removeIncident(payload) {
        const candidates = this.putMessageOnPipe('removeIncident', {
                incidentId: payload.id,
                parentGroupId: payload.parentGroupId,
                contextData: {
                    clipId: this.id,
                    context: this.context
                },
                audio: this.audioClip
            },
            payload.parentGroupId, { selfExecute: true, direction: _TREECONST._DIRECTIONS._DOWN });

        const totalIncidentsByPlugin = {};
        for (let i = 0; i < candidates.length; i++) {
            const incidentsByPlugin = candidates[i].response.getIncidentsByChannel();
            for (let pluginName in incidentsByPlugin) {
                if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
                    totalIncidentsByPlugin[pluginName] = [];
                }
                totalIncidentsByPlugin[pluginName].push(...incidentsByPlugin[pluginName]);
            }
        }

        const res = this.checkDelete(totalIncidentsByPlugin);
        if (res.result === true) {
            const successCallback = () => {
                res.execute();
                for (let i = 0; i < candidates.length; i++) {
                    candidates[i].responder.removeChild(candidates[i].response.id);

                    // recalculate duration the groups that we added
                    // the incidents to along with their parents
                    candidates[i].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
                }
            }
            return {
                result: true,
                execute: successCallback
            }
        }
        return res;
    }


    /**
     * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident
     * is valid and accepted, according to the rules defined on the channels.
     * The method boobles up until it reaches the Clip.
     * @param {object} incident - the incident to edit
      The result might be either:
        {
            result:true,
            execute: // an array of functions that when executed it will remove the Incident on the Channels
        }
        or
        {
            result: false,
            errors
        }
    */
    checkDelete(incidentsById) {
        // prepare the return payload
        let toReturnResult = true;
        let toReturnErrors = [];
        let toReturnExecutables = [];

        // for each key of the incidentsById object perform the check
        for (let key in incidentsById) {
            // perform the check
            const pluginResult = this.instantiatedChannels[key].removeIncidents(incidentsById[key]);
            toReturnResult = toReturnResult && pluginResult.result;
            if (pluginResult.result === false) {
                toReturnErrors = toReturnErrors.concat(pluginResult.errors);
            }
            else {
                toReturnExecutables.push(pluginResult.execute);
            }
        } // enf of iteration on the incidentsById keys

        const toReturnExecute = function () {
            for (let i = 0; i < toReturnExecutables.length; i++) {
                toReturnExecutables[i]();
            }
        }

        const removeResult = {
            result: toReturnResult,
            errors: toReturnErrors,
            execute: toReturnExecute
        }
        return removeResult;
    }

    /**
     * This command is invoked by the Clip's parent Descriptor class. The payload
     * is identical to the payload that comes to the Description class:
     * {
     *  id: the id of the Incident to resize
     *  newSize: the milliseconds of the new duration
     *  fraction: the division of the new duration to the current
     * }
     */
    resizeIncident(payload) {
        const candidates = this.putMessageOnPipe('resize', {
                incidentId: payload.id,
                newSize: payload.newSize,
                fraction: payload.fraction,
                contextData: {
                    clipId: this.id,
                    context: this.context
                },
                audio: this.audioClip
            },
            payload.id, { selfExecute: false, direction: _TREECONST._DIRECTIONS._DOWN });

        const totalIncidentsByPlugin = {};
        for (let i = 0; i < candidates.length; i++) {
            const incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta);
            for (let pluginName in incidentsByPlugin) {
                if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {
                    totalIncidentsByPlugin[pluginName] = [];
                }
                totalIncidentsByPlugin[pluginName].push(...incidentsByPlugin[pluginName]);
            }
        }

        let positionDelta = 0;
        if (candidates.length > 0) {
            positionDelta = candidates[0].positionDelta;
        }
        const res = this.checkResize(payload.fraction, totalIncidentsByPlugin, positionDelta);
        if (res.result === true) {
            const successCallback = () => {
                res.execute();
                for (let i = 0; i < candidates.length; i++) {
                    candidates[i].responder.setNewDuration(payload.newSize);
                }
            }
            return {
                result: true,
                execute: successCallback
            }
        }
        return res;
    }

    /**
     * checks if a duration edit is feasible and doesn't cause conflicts
     * @param {int} duration - the new duration
     **/
    checkResize(durationFraction, incidentsById, adjustMillisecond = 0) {
        // prepare the return payload
        let toReturnResult = true;
        let toReturnErrors = [];
        let toReturnExecutables = [];
        // for each key of the incidentsById object perform the check
        for (let key in incidentsById) {
            // perform the check
            const adjustedIncidents = helper.systoleDiastoleProjections(incidentsById[key], durationFraction, adjustMillisecond);
            const pluginResult = this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);
            toReturnResult = toReturnResult && pluginResult.result;
            if (pluginResult.result === false) {
                toReturnErrors = toReturnErrors.concat(pluginResult.errors);
            }
            else {
                toReturnExecutables.push(pluginResult.execute);
            }
        } // enf of iteration on the incidentsById keys

        const toReturnExecute = function () {
            for (let i = 0; i < toReturnExecutables.length; i++) {
                toReturnExecutables[i]();
            }
        }

        const editResult = {
            result: toReturnResult,
            errors: toReturnErrors,
            execute: toReturnExecute
        }
        return editResult;

    }


    get context() {
        return this.ownContext;
    }


    /**
     * Returns an object with keys the keys of all the plugins Incidents of which appear in the
     * tree of the Group. All Incidents are projected to the Group's timeline.
     * The array includes the Group's projection too
     */
    getIncidentsByChannel(adjustMillisecond = 0) {
        let incidentsByPlugin = {};
        incidentsByPlugin[selfContainedIncidentsNpmName] = [{
            millisecond: adjustMillisecond,
            incident: this,
            id: this.id
        }];

        return incidentsByPlugin;
    }


    setVolume(newVal) {
        this.volume = parseFloat(newVal);
        // this.putMessageOnPipe(pipeMessages._GAIN_CHANGE, { gain: newVal }, false, "down");
    }

    /**
     * Eventhough Clips have their own context, still they might belong to another Clip's
     * tree (CASI). In such a case this method gives the oportunity to set things up
     * and do operations related with their parent's context (such as subscribing to audio effect nodes)
     **/
    _onGetContextOnce(parentClipContext) {
        return;
    }


    // special recalcDuration handling so any potential clip copies update their trees
    handleRecalcDuration(target, payload) { // eslint-disable-line no-unused-vars
        if (this._calculateDuration()) {
            for (let i = 0; i < this.durationSubs.length; i++) {
                this.durationSubs[i](this.duration);
            }
        }
        return true;
    }


    /**
     * Method called on progress of the timed incident.
     * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered
     * @param {int} milliseconds - the number of milliseconds passed from start of the incident
     * @param {string} contextId - defaults to the id of the realClip itself. Don't forget that a realClip
     *      might belong to a selector Clip (so it's a Fragmented Clip), with many "real" ClipCopies. All ClipCopies hold
     *      a reference to this Clip via their "realClip" property. Whenever any
     *      of these ClipCopies progresses (via the onProgress method) calls
     *      the "onProgress" of the realClip, passing their id so the ContextAwareIncidents
     *      that will also progress via the Channels know which specific Incident to progress.
     *      That's the result of keeping just one real tree, belonging always to the realClip
     *      (either Fragmented or Hosted) ending to ContextAwareIncident leafs that
     *      are the ones to hold the ClipCopies instances.
     * @param {boolean} forceReset - set to true in cases we want full flash of the state
     */
    onProgress(fraction, milliseconds, contextId, forceReset = false) {
        if (this.contextReady === false) {
            this.setBlock();
            return;
        }
        if (!contextId) {
            contextId = this.id;
        }
        for (let key in this.instantiatedChannels) {
            const channel = this.instantiatedChannels[key];
            channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, contextId, forceReset);
        }
    }

    flash() {
        for (let key in this.instantiatedChannels) {
            const channel = this.instantiatedChannels[key];
            channel.moveTo(0, this.runTimeInfo.currentMillisecond, this.id, true);
        }
    }

    // duration changes pub/sub
    subscribeToDurationChange(method) {
        this.durationSubs.push(method);
    }


    /********************************************************/
    /******** BLOCKING WAITINGS SET / REMOVE ***************/
    handleSetBlockingWaiting(target, payload) {
        console.log('handling set blocking waiting');
        console.log(payload);
    }

    handleRemoveBlockingWaiting(target, payload) {
        console.log('handling remove blocking waiting');
        console.log(payload);
    }


}

module.exports = ExtendableClip;
