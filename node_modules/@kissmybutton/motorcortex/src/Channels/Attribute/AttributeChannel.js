const Channel = require('../Channel');
const Helper = require('../../_coreUtils/Helper');
const helper = new Helper();

const _filter = require('../../../lodash-custom-build/modularize/lodash.filter/index');
const _sortBy = require('../../../lodash-custom-build/modularize/lodash.sortby/index');

const lanesHandler = require('./LanesHandler');



class AttributeChannel extends Channel {
    constructor(props) {
        super(props);

        /*
        comboAttributes are attributes of type object, holding a number of other attributes.
        E.g. CSS "transform" attribute is a combo that holds a number of other attributes such as:
        translateX, translateY, etc. The lanes handler keeps just one lane for the combo attrs
        in an object format keeping the value of each attribute at any given point.
        Combo attributes are passed on the constructor of the Channel in the format:
        props.comboAttributes: {
            transition: ['translateX', 'translateY', ...],
            <something_else>: ['<attrName1>', '<attrName2>', ...]
        }
        */
        this.comboAttributes = {};

        /**
         * For incidents that do not have animatedAttrs there should be only one lane per element.
         * The attributes Channel will use a default (fake), fixed attribute for this cases so it always ends
         * up with just one lane per element: <element_id>_<this.fixedAttributeName>
         */
        this.fixedAttributeName = "_";
        if (props.comboAttributes != null) {
            this.comboAttributes = props.comboAttributes;
        }

        this.LanesHandler = new lanesHandler({ comboAttributes: this.comboAttributes, runTimeInfo: this.runTimeInfo });
        // this.type = "attributes";
    }

    static get type() {
        return "attributes";
    }

    setComboAttributes(comboAttributes) {
        this.comboAttributes = comboAttributes;
        this.LanesHandler = new lanesHandler({ comboAttributes: this.comboAttributes });
    }

    get lanes() {
        return this.LanesHandler.lanes;
    }

    get incidentsById() {
        return this.LanesHandler.incidentsById;
    }

    _resize(durationFraction) {
        this.LanesHandler._resize(durationFraction);
    }


    /* *******************************************************
     DECISION METHODS
     ********************************************************/

    /**
     * All of the incidents coming to this method are element-attribute incidents meaning that they only
     * target just one element and also they include just a single attribute on the incident.attrs.animatedAttrs
     * object
     *
     * @param {array} incidents - A collection of Incidents in the form:
     * {
     *  millisecond
     *  incident
     *  id
     * }
     * @param {string} type - can be either "all-or-nothing" (default) or "keep-passing". If type = "all-or-nothing"
     *  the addition passes only if all incidents pass. If type = "keep-passing" the method will still return true
     *  but will also include an errors array on its return and also will only include the success callbacks on
     *  the execute key of its return
     * @returns either:
     *   {
     *       result:true,
     *       execute: // an array of functions that when executed it will add the Incidents on the Channels
     *   }
     *   or
     *   {
     *       result: false,
     *       errors
     *   }
     */
    checkAddition(incidents, type = "all-or-nothing") {
        const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();
        /* an array where we keep all affected lanes so we can slip on them at the end.
        The format for each affected lane we keep is:
        {
            mcid: mcid,
            attribute: attribute
        }
        */
        let affectedLanes = [];


        // while the LanesHandlerSanbox adds lane items it makes decisions of which permanent changes should be made to
        // the permanent and pre-existing objects it handles, such as changes on the initial values of existing animations.
        // Because of the fact the LanesSandboxHandler is only there for testing we don't want to execute these changes
        // during checks but still we need to know them on success. For this, the onSuccessActions array holds all executable
        // functions retured by various LanesHandlerSanbox functions so it can execute them on success.
        let onSuccessActions = [];

        let conflicts = [];
        for (let i = 0; i < incidents.length; i++) {
            let incidentConflicts = false; // a boolean that keeps the information whether the incident conflicts or not
            const laneItem = incidents[i];
            const incident = laneItem.incident;

            const mcid = incident.mcid;
            const attribute = incident.attribute || this.fixedAttributeName;

            LanesHandlerSandbox.laneExists(mcid, attribute); // create the lane if it doesn't exist already

            affectedLanes.push({
                mcid: mcid,
                attribute: attribute
            });

            // **** if the lane did exist before the new addition check for conflicts
            let overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(laneItem, mcid, attribute);

            // helper.log(overlappingAnim)
            if (overlappingAnims.length > 0) {
                incidentConflicts = true;
                conflicts.push({
                    type: 'unauthorised, overlapping incidents on the same element',
                    meta: {
                        element_mcid: mcid,
                        attribute: attribute,
                        incident: laneItem,
                        overlappingAnims: overlappingAnims
                    }
                });
            }

            if (!incidentConflicts) {
                onSuccessActions.push(function () {
                    LanesHandlerSandbox.addElementToLane(mcid, attribute, laneItem.millisecond, incident);
                    incident._onGetContextOnce();
                });
            }

        } // end for each incident

        // if we have conflicts and the type = "all-or-nothing"
        if (conflicts.length > 0 && type === "all-or-nothing") {
            return {
                result: false,
                errors: conflicts
            }
        }
        else {
            // as soon as we want all passing additions to get applied the Lanes Handler will create a callback that will be passed to the result.
            // This callback will apply all passing additions.

            // success message
            const that = this;
            const exec = function () {
                for (let i = 0; i < onSuccessActions.length; i++) {
                    onSuccessActions[i]();
                }
                that.LanesHandler.applySandboxChanges(LanesHandlerSandbox);
            }

            return {
                result: true,
                errors: conflicts,
                execute: exec
            }
        }
    }

    /**
     * It initially checks if the edit is allowed and if it is it retuns an array of executable functions
     * that apply the change
     * @param {array} incidents - the list of the lane items to edit in an array format [object, object, ...]
     * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents
     * @returns {object} -
     * either:
     {
        result: true,
        execute: // array of functions to be executed in order to apply the edit
     }
     or
     {
         result: false,
         errors: // an array including all the errors / conflicts found on edit
     }
    */
    checkEdit(incidents, millisecondsDelta) {
        // console.log(incidents);
        const affectedIncidentIds = [];
        for (let i = 0; i < incidents.length; i++) {
            affectedIncidentIds.push(incidents[i].id);
        }

        const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();

        let conflicts = [];
        let affectedLanes = [];

        // for each of the affectedAnimations
        for (let i = 0; i < incidents.length; i++) {
            const incident = incidents[i].incident;
            const incidentId = incident.id;
            const mcid = incidents[i].incident.mcid;
            const attribute = incidents[i].incident.attribute || this.fixedAttributeName;

            const lane = LanesHandlerSandbox.getLane(mcid, attribute);
            const laneAttrs = {
                mcid: mcid,
                attribute: attribute
            }

            // check for conflicts and edit lane items millisecond
            for (let k = 0; k < lane.length; k++) {
                if (lane[k].id === incidentId) {
                    affectedLanes.push(laneAttrs);
                    let affectedAnim = lane[k];
                    let testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);
                    testLaneElement.millisecond += millisecondsDelta;
                    testLaneElement.incident = LanesHandlerSandbox.incidentsById._get(testLaneElement.id);
                    let overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, mcid, attribute, affectedIncidentIds);

                    if (overlappingAnims.length > 0) {
                        conflicts.push({
                            type: 'anauthorised, overlapping animations on the same element',
                            meta: {
                                element_mcid: mcid,
                                attribute: attribute,
                                newAnimation: testLaneElement,
                                overlappingAnims: overlappingAnims
                            }
                        });
                    }

                    break;
                } // end of if we found the specific animation on the lane's sequence
            } // end of each lane's item


        } // end for each affected animation's id

        if (conflicts.length > 0) {
            return {
                result: false,
                errors: conflicts
            }
        }
        else {
            const that = this;
            const exec = function () {
                that.LanesHandler.updateLane(affectedIncidentIds, millisecondsDelta);
            }
            return {
                result: true,
                execute: exec
            }

        }
    }


    /**
     * @param {array} incidents - [{id, start, end, startDelta}]
     * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in
     *  that case no checks should be actually perfomed nor the projected candidate should be applied directly
     **/
    checkResizedIncidents(incidents, fullChannelResize = false) {
        const excludeIdsFromCheck = [];
        for (let i = 0; i < incidents.length; i++) {
            excludeIdsFromCheck.push(incidents[i].id);
        }

        const LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();

        let conflicts = [];
        let affectedLanes = [];

        // for each of the incidents passed
        for (let i = 0; i < incidents.length; i++) {
            // get the ContextAwareIncident
            const incident = this.LanesHandler.incidentsById._get(incidents[i].id);
            const mcid = incident.mcid;
            const attribute = incident.attribute || this.fixedAttributeName;

            const lane = LanesHandlerSandbox.getLane(mcid, attribute);
            const laneAttrs = {
                mcid: mcid,
                attribute: attribute
            }

            const testDuration = incidents[i].end - incidents[i].start;

            // check for conflicts and edit lane items millisecond
            for (let k = 0; k < lane.length; k++) {
                if (lane[k].id === incidents[i].id) {
                    affectedLanes.push(laneAttrs);
                    if (fullChannelResize === false) {
                        let affectedAnim = lane[k];
                        let testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);
                        testLaneElement.millisecond += incidents[i].startDelta;
                        testLaneElement.incident = LanesHandlerSandbox.incidentsById._get(testLaneElement.id);
                        let overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, laneAttrs.mcid, laneAttrs.attribute, excludeIdsFromCheck, testDuration);

                        if (overlappingAnims.length > 0) {
                            conflicts.push({
                                type: 'anauthorised overlapping animations on the same element',
                                meta: {
                                    element_mcid: laneAttrs.mcid,
                                    attribute: laneAttrs.attribute,
                                    newAnimation: testLaneElement,
                                    overlappingAnims: overlappingAnims
                                }
                            });
                        }
                    }

                    break;
                } // end of if we found the specific animation on the lane's sequence
            } // end of each lane's item


        } // end for each affected animation's id

        if (conflicts.length > 0) {
            return {
                result: false,
                errors: conflicts
            }
        }
        else {
            const that = this;

            const exec = function () {
                // updateLanes (only this time animation by animation as the milliseconds delta is not standard for all)
                // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the
                // success message
                for (let i = 0; i < incidents.length; i++) {
                    that.LanesHandler.updateLane([incidents[i].id], incidents[i].startDelta);
                }
            }

            return {
                execute: exec,
                result: true
            }
        }
    }

    /**
     *
     */
    checkDelete(removedAnimations, props = {}) { // eslint-disable-line no-unused-vars
        let removedAnimationIds = [];
        for (let i = 0; i < removedAnimations.length; i++) {
            removedAnimationIds.push(removedAnimations[i].id);
        }

        const that = this;
        const exec = function () {
            that.LanesHandler.deleteAnimations(removedAnimationIds);
        }

        return {
            result: true,
            execute: exec
        }

    }

    /**
     * This method is responsible for recalculating the scratch values of the first
     * Incident of each of the lanes of the LanesHandler according to the provided
     * context id
     **/
    recalcScratchValues(contextId) {
        this.LanesHandler.recalcScratchValues(contextId);
    }

    /**
     * Slips to just one lane forwards
     * @param {array} lane - the lane to slip into
     * @param {object} laneData - an object with keys: attribute & mcid
     * @param {int} currentMillisecond - the millisecond the slip starts from
     * @param {int} millisecond - the target millisecond of the slip
     * @param {string} contextId - the contextId of the Incidents to slip
     */
    slipIntoLaneForwards(lane, laneData, currentMillisecond, millisecond, contextId, forceReset = false) {
        // console.log(lane, currentMillisecond, millisecond);
        const that = this;
        let participatingAnims = _filter(lane, laneItem => {
            return (
                (laneItem.millisecond + that.incidentsById._get(laneItem.id).duration >= currentMillisecond &&
                    laneItem.millisecond + that.incidentsById._get(laneItem.id).duration <= millisecond) || // it ends after currentMillisecond and before target millisecond
                (that.incidentsById._get(laneItem.id).duration + laneItem.millisecond >= millisecond &&
                    laneItem.millisecond <= millisecond)
            ); // or it ends after the target millisecond but also starts before it
        });

        if (participatingAnims.length == 0) {
            if (forceReset === true) {
                const firstIncident = this.incidentsById._get(lane[0].id);
                firstIncident.onProgress(0, 0, contextId)
            }
            return true;
        }

        participatingAnims = _sortBy(participatingAnims, [
            laneItem => {
                return laneItem.millisecond;
            }
        ]);

        // We only care about the last (in chronological order) Incident, as this
        // will define the final value
        const lastIndex = participatingAnims.length - 1;
        const participatingAnim = this.incidentsById._get(participatingAnims[lastIndex].id);
        const startMillisecond = participatingAnims[lastIndex].millisecond;

        // if the animation ends before the target millisecond
        if (participatingAnim.duration + startMillisecond <= millisecond) {
            // and it's the last one on the row
            participatingAnim.onProgress(1, participatingAnim.duration, contextId);
        }
        else {
            // slip for the specific element and the specific attribute. Set the Animation as paused or playing a
            // and store this info somewhere
            const percentageComplete =
                (millisecond - startMillisecond) / participatingAnim.duration;
            participatingAnim.onProgress(percentageComplete, millisecond - startMillisecond, contextId);
        }
    }

    /**
     * Slips to just one lane backwards
     * @param {array} lane - the lane to slip into
     * @param {object} laneData - an object with keys: attribute & mcid
     * @param {int} currentMillisecond - the millisecond the slip starts from
     * @param {int} millisecond - the target millisecond of the slip
     * @param {string} contextId - the contextId of the Incidents to slip
     */
    slipToLaneBackwards(lane, laneData, currentMillisecond, millisecond, contextId, forceReset = false) {
        // we take all Animations that are either currently running or
        // they end after the destination point
        // helper.log('<------');
        const that = this;

        let participatingAnims = _filter(lane, laneItem => {
            const laneItemEnd = that.incidentsById._get(laneItem.id).duration + laneItem.millisecond;
            return (
                (laneItemEnd <= millisecond && laneItemEnd >= currentMillisecond) || // they end in the hot area
                (laneItem.millisecond >= currentMillisecond &&
                    laneItem.millisecond <= millisecond) || // they start in the hot area
                (laneItem.millisecond < currentMillisecond && laneItemEnd > millisecond)
            ); // they overlap the hot area
        });

        // let participatingAnims = _filter(lane, laneItem => {
        //     const laneItemEnd = that.incidentsById._get(laneItem.id).duration + laneItem.millisecond;
        //     return (
        //         (laneItemEnd >= millisecond && laneItemEnd <= currentMillisecond) || // they end in the hot area
        //         (laneItem.millisecond >= millisecond && laneItem.millisecond <= currentMillisecond) // they start in the hot area
        //     ); // they overlap the hot area
        // });

        if (participatingAnims.length == 0) {
            if (participatingAnims.length == 0) {
                if (forceReset === true) {
                    const firstIncident = this.incidentsById._get(lane[lane.length - 1].id);
                    firstIncident.onProgress(1, firstIncident.duration, contextId)
                }
                return true;
            }
            return true;
        }

        participatingAnims = _sortBy(participatingAnims, [
            laneItem => {
                return laneItem.millisecond;
            }
        ]);

        // We only care about the first (in chronological order) Incident, as this
        // will define the final value of the backwards move
        const lastIndex = 0;
        const participatingAnim = this.incidentsById._get(participatingAnims[lastIndex].id);
        const startMillisecond = participatingAnims[lastIndex].millisecond;

        // if the animation starts after the target millisecond
        if (startMillisecond >= millisecond) {
            participatingAnim.onProgress(0, 0, contextId);
        }
        else {
            // slip for the specific element and the specific attribute. Set the Animation as paused or playing a
            // and store this info somewhere
            const percentageComplete =
                (millisecond - startMillisecond) / participatingAnim.duration;

            participatingAnim.onProgress(percentageComplete, millisecond - startMillisecond, contextId);
        }
    }

    /**
     @param {int} from - the millisecond to start from
     @param {int} to - the millisecond to go to
     @param {sring} contextId - the context id to "move"
     @param {boolean} forceReset - set to true if status recalc is needed after edit
     */
    moveTo(from, to, contextId, forceReset = false) {
        // step 1: iterate through all lanes
        const laneKeys = this.lanes._keys();
        for (let i = 0; i < laneKeys.length; i++) {
            const laneid = laneKeys[i];
            const lane = this.lanes._get(laneid);
            const laneData = helper.getMCIDandAttrOutOfLaneKey(laneid);
            if (from <= to) {
                this.slipIntoLaneForwards(
                    lane,
                    laneData,
                    from,
                    to,
                    contextId,
                    forceReset
                );
            }
            else if (from > to) {
                this.slipToLaneBackwards(
                    lane,
                    laneData,
                    from,
                    to,
                    contextId,
                    forceReset
                );
            }
        }
    }
}

module.exports = AttributeChannel;
