const Playable = require('../Clip/Playable');
const _TREECONST = require('../Tree/_CONST');
const FragmentedClip = require('../Clip/FragmentedClip');
const Clip = require('../Clip/DOMClip');
const Channel = require('../Channels/Clip/ClipsChannel');
const incidentFromIngredients = require('../IncidentFromDefinition/incidentFromIngredients');
const ClipClone = require('../Clip/RootClipClone');
const AudioClip = require('../Audio/AudioClip');
const NullClip = require('../Clip/NullClip');

/**
 * Along with the expected props for the Clip on the props support the audio key.
 * The audio can take one of the 3 following values:
 * - "on": The Clip has audio enabled
 * - "off": The Clip has audio disabled
 * - "only": The Clip is only audio
 *
 * Also, in the case audio is on or only the user should pass the "audioSources"
 * key containing all the audio sources they want to pass on the Audio Context
 * of their clip. Please check AudioClip for details on the expected format
 **/
class DescriptiveClip extends Playable {
    constructor(attrs, props = null) {
        let attrsToPass, propsToUse;

        if (props === null) {
            attrsToPass = {};
            propsToUse = attrs;
        }
        else { // else, in case the user has passed two arguments then both should be used
            attrsToPass = attrs;
            propsToUse = props;
        }

        super(attrsToPass, propsToUse);

        // isTheRootClip defines whether the Clip is the root or not. It depends on
        // the host or selector parameter passed on props (if host is present then
        // the Clip is the root Clip while if the Clip gets initialised by a selector
        // is not)
        this.isTheRootClip = false;

        // check if
        let ingredients = {
            id: this.id,
            attrs: attrsToPass,
            props: {
                ...propsToUse,
                html: Object.prototype.hasOwnProperty.call(propsToUse, "html") ? propsToUse.html : this.html,
                css: Object.prototype.hasOwnProperty.call(propsToUse, "css") ? propsToUse.css : this.css,
                fonts: Object.prototype.hasOwnProperty.call(propsToUse, "fonts") ? propsToUse.fonts : this.fonts,
                runTimeInfo: this.runTimeInfo,
                subscribe: this.subscribe.bind(this)
            },
            plugin_npm_name: this.constructor.plugin_npm_name,
            Channel: this.constructor.Channel,
            DescriptiveIncident: this
        };

        // Decide what kind of audio (or non-audio) Clip we are dealing with
        this.audio = "on";
        if (Object.prototype.hasOwnProperty.call(this.constructor, 'audio')) {
            this.audio = this.constructor.audio;
        }
        if (Object.prototype.hasOwnProperty.call(propsToUse, 'audio')) {
            this.audio = propsToUse.audio;
        }

        // decide if this is the root clip
        if (Object.prototype.hasOwnProperty.call(propsToUse, "selector") && propsToUse.selector !== undefined &&
            this.constructor.customClip !== true) {
            ingredients.Incident = FragmentedClip;
            // TODO it doesn't take in account the get html and get css of the Descriptive Clip
        }
        else if (Object.prototype.hasOwnProperty.call(propsToUse, "selector") && propsToUse.selector !== undefined &&
            this.constructor.customClip === true) {
            delete ingredients.props.selector;
            const FragmentWrapper = new FragmentedClip({
                html: '<div id="clip-container"></div>'
            });
            ingredients.props.host = FragmentWrapper.rootElement;
            ingredients.Incident = this.constructor.Incident;
        }
        else if (this.audio === "only" && this.props.root !== true) { // audioClips can never be the root
            this.isTheRootClip = false;
        }
        else {
            this.isTheRootClip = true;

            /*
            blockingWaitings are been triggered by Incidents when there is the
            need to halt the Clip's execution and wait. As an example a blocking
            waiting can be set by an Audio Playback Incident when the audio has
            not been loaded yet.
            Each blocking waiting has an id and via the same id the waiting can be
            unblocked.
            The blockingWaitings property of the root Clip is a collection with
            keys the blocking waitings ids and values the description of each waiting
            which consists of:
            {
                id
                description
                incidentId
            }
            The blocking waitings are triggered by real Incidents living on the real
            Clips of the Descriptive Clip (either the audioClip or the realClip).
            The root that a waiting set or unset follows is from any real incident
            up to its ContextAware Incident and from there
            up to the real Clip and from thre to its DescriptiveTree and from there
            all the way up to the root Descriptive Clip.
            Blocking waitings must always be triggered on the "onProgress" or on
            the "play" methods of Incidents. Setting a blocking waiting from anywhere
            else is an error
            */
            this.blockingWaitings = {};

            ingredients.Incident = this.constructor.Incident;
        }

        // we initialise real and audio clips of the Clip by checking the static audio
        // property
        // the property this.audio helps incidentFromDescription identify if the Incident
        // participates or not on the audioClip. By default is "on" but if the props.audio is set to off
        // it turns to "off" so the DC gets totally ignored on the addition process on audio clip
        /* The audio value is set in the following manner
            - first we check if the Class has a static audio parameter and if yes we keep it
            - then we check if this.props has the audio key and if yes we keep this one
            - otherwise we use the default ("on")
        */
        if (this.audio === 'on' || this.audio === 'off') {
            this.realClip = incidentFromIngredients(ingredients);
        }
        else {
            this.realClip = new NullClip();
        }

        if (this.audio === 'on' || this.audio === 'only') {
            const audioIngredients = {
                id: this.id,
                attrs: {},
                props: {
                    audioSources: Object.prototype.hasOwnProperty.call(propsToUse, "audioSources") ? propsToUse.audioSources : this.audioSources,
                    runTimeInfo: this.runTimeInfo,
                    subscribe: this.subscribe.bind(this)
                },
                plugin_npm_name: this.constructor.plugin_npm_name,
                Channel: this.constructor.Channel,
                Incident: AudioClip,
                DescriptiveIncident: this
            };
            this.audioClip = incidentFromIngredients(audioIngredients);
        }
        else {
            this.audio = false;
            this.audioClip = new NullClip();
        }


        // passiveAddition is a flag property indicating that any Incident to be
        // added to the Clip will be passive. It initialises with value = false
        // on DescriptiveGroup where it's originaly defined.
        // Here we change its value just before the buildTree method execution
        // so all Incidents added on it get the "passive" flag and don't get
        // exported on the exportDefinition method. Once the buildTree method
        // finishes we set it back to its original value (false)
        this.passiveAddition = true;
        this._buildTree();
        this.passiveAddition = false;
    }

    static isClip = true; // a static member to help incidentFromDefinition identify clips
    static Incident = Clip;
    static plugin_npm_name = "@kissmybutton/self-contained-incidents";
    static Channel = Channel;
    static ClassName = "Clip";

    get selectorToPassToChildren() {
        return null; // the Clip (any Clip) resets the selection cascading
    }

    get inheritedSelector() {
        return this._inheritedSelector;
    }

    set inheritedSelector(value) {
        this._inheritedSelector = value;
    }

    get html() {
        return '';
    }

    get css() {
        return '';
    }

    get fonts() {
        return [];
    }

    get audioSources() {
        return [];
    }

    /*
    the _buildTree method acts as a proxy to the buildTree method defined by the
    developers. The reason for this is that the actual buildTree method should
    be executed in different order on Groups and on Clips (that extend Groups).
    Calling the super on constructor fires the _buildTree execution on the
    Group's constructor but this breaks on Clip as the realClip has not been
    initialised yet.
    */
    _buildTree() {
        if (this.realClip === undefined) {
            return;
        }
        this.buildTree();
    }

    /**
     * When the resize command is given directly to a DescriptiveClip no checks
     * need to be performed.
     * DescriptiveClip directly invokes the _resize method of ExtendableClip which
     * resizes the full clip
     */
    resize(newSize) {
        this.realClip._resize(newSize / this.duration);
        this.audioClip._resize(newSize / this.duration);

        this.duration = newSize;
        this.putMessageOnPipe('recalcDuration', {}, 'Groups', { selfExecute: false, direction: _TREECONST._DIRECTIONS._UP });
        this.putMessageOnPipe('flash', {}, 'RootClip', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });

        return {
            result: true
        }
    }

    /*************************** HANDLING METHODS *******************************/
    handleCheckForClip(target, payload) { // eslint-disable-line no-unused-vars
        return true;
    }

    handleCheckAddition(target, payload) {
        /* Is the responsibility of the DescriptiveClip to pass the addition request
        to its real clip and expect for a response. */
        const res = this.realClip.addIncident(payload);
        const audioRes = this.audioClip.addIncident(payload);
        if (res.result === true && audioRes.result === true) {
            res.execute();
            audioRes.execute();
            this.putMessageOnPipe('flash', {}, 'RootClip', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
            return {
                result: true
            }
        }
        return res;
    }

    handleCheckMove(target, payload) {
        const res = this.realClip.moveIncident(payload);
        const audioRes = this.audioClip.moveIncident(payload);
        if (res.result === true && audioRes.result === true) {
            res.execute();
            audioRes.execute();
            this.putMessageOnPipe('flash', {}, 'RootClip', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
            return {
                result: true
            }
        }
        return res;
    }

    handleCheckDeletion(target, payload) {
        const res = this.realClip.removeIncident(payload);
        const audioRes = this.audioClip.removeIncident(payload);
        if (res.result === true && audioRes.result === true) {
            res.execute();
            audioRes.execute();
            this.putMessageOnPipe('flash', {}, 'RootClip', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
            return {
                result: true
            }
        }
        return res;
    }

    handleCheckResize(target, payload) {
        const res = this.realClip.resizeIncident(payload);
        const audioRes = this.audioClip.resizeIncident(payload);
        if (res.result === true && audioRes.result === true) {
            res.execute();
            audioRes.execute();
            this.putMessageOnPipe('flash', {}, 'RootClip', { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
            return {
                result: true
            }
        }
        return res;
    }

    handleFlash(target, payload) { // eslint-disable-line no-unused-vars
        if (this.isTheRootClip) {
            this.flash();
        }
        else {
            return this.bypass();
        }
    }


    /****************** BLOCKING WAITINGS HANDLING **************************/
    /***********************************************************************/
    handleSetBlock(target, payload) {
        // only accepts blocks if is the root clip and if it's playing
        if (this.isTheRootClip) {
            if (this.runTimeInfo.state === "transitional") {
                return;
            }

            if (this.runTimeInfo.state !== 'blocked') {
                this.statusBeforeBlock = this.runTimeInfo.state;
            }

            this.blockingWaitings[payload.id] = payload;
            this.block();
        }
        else {
            return this.bypass();
        }
    }

    handleUnBlock(target, payload) {
        if (this.isTheRootClip) {
            if (Object.prototype.hasOwnProperty.call(this.blockingWaitings, payload.id)) {
                delete this.blockingWaitings[payload.id];
                if (Object.keys(this.blockingWaitings).length === 0) {
                    if (this.statusBeforeBlock === "playing") {
                        this.previousTimeStamp = -1;
                        this.play();
                    }
                    else {
                        this.arm();
                    }
                }
            }
        }
        else {
            return this.bypass();
        }
    }

    /* empty blocking waitings on transition start */
    stop() {
        super.stop();
        this.blockingWaitings = {};
    }

    /***********************************************************************/
    /***********************************************************************/

    onProgress(fraction, millisecond) {
        this.realClip.onProgress(fraction, millisecond);
        this.audioClip.onProgress(fraction, millisecond);
    }

    /*************************************************************/
    paste(host) {
        if (this.isTheRootClip) {
            const clipClone = new ClipClone({
                host: host,
                descriptiveIncident: this
            });
            return clipClone;
        }
        return null;
    }

    flash() {
        this.realClip.flash();
    }

    setVolume(vol) {
        if (vol < 0 || vol > 1) {
            return {
                result: false,
                errors: [{
                    type: 'invalid volume number'
                }]
            }
        }
        else if (this.audio === 'off') {
            return {
                result: false,
                errors: [{
                    type: 'can not set volume of Clip with audio off'
                }]
            }
        }
        else {
            this.audioClip.setVolume(vol);
            return { result: true }
        }
    }
}

module.exports = DescriptiveClip;
