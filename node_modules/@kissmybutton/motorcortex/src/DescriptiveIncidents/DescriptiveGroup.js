const _CONST = require('./_CONST');
const _TREECONST = require('../Tree/_CONST');
const Node = require('../Tree/Node');
const resize = require('./decorators/resize');
const editAttributes = require('./decorators/editAttributes');
const editProperties = require('./decorators/editProperties');
const selectorGetter = require('./decorators/selector');
const Group = require('../BaseClasses/Group');
const Channel = require('../Channels/Channel');

class DescriptiveGroup extends Node {
    static Incident = Group;
    static plugin_npm_name = "motor-cortex-js";
    static Channel = Channel;
    static ClassName = "Group";

    constructor(attrs = {}, props = null) {
        if (props === null) {
            super(attrs);
            this.attrs = {};
            this.props = attrs;
        }
        else {
            super(props);
            this.attrs = attrs;
            this.props = props;
        }

        this._inheritedSelector = null;

        // passiveAddition is a flag property indicating that any Incident to be
        // added to the Clip will be passive. It initialises with value = false
        // on DescriptiveGroup where it's originaly defined.
        // Here we change its value just before the buildTree method execution
        // so all Incidents added on it get the "passive" flag and don't get
        // exported on the exportDefinition method. Once the buildTree method
        // finishes we set it back to its original value (false)
        this.passiveAddition = true;
        this._buildTree();
        this.passiveAddition = false;
    }

    @editAttributes
    editAttributes() {}

    @editProperties
    editProperties() {}

    @resize
    resize() {}

    @selectorGetter
    selector() {}

    _buildTree() {
        this.buildTree();
    }

    _rebuildTree() {
        // remove all direct passive incidents as they might be dependent on the edited attrs/props
        for (let id in this.children) {
            const theChild = this.children[id];
            if (theChild.leaf.passive === true) {
                this.removeIncident(theChild.id);
            }
        }
        // run buildTree again
        this.passiveAddition = true;
        this.buildTree();
        this.passiveAddition = false;
    }

    buildTree() {

    }

    manageEditAttrProps(newAttrs, type) {
        // get a permanent reference to its parent node
        const parentNode = this.parentNode;
        // get the position of the Incident within its parent
        const position = parentNode.getLeafPosition(this.id);
        // keep a backup of the current attrs / props
        const oldAttrs = JSON.parse(JSON.stringify(this[type]));
        this[type] = newAttrs;
        // first detach the Incident from its parent
        parentNode.removeIncident(this.id);
        // remove all direct passive incidents as they might be dependent on the edited attrs/props
        this._rebuildTree();
        // try to add the altered Group
        const res = parentNode.addIncident(this, position);

        if (res.result === false) {
            this[type] = oldAttrs;
            this._rebuildTree();
            parentNode.addIncident(this, position);
            return res;
        }
        return res;
    }

    detachFromParent() {
        super.detachFromParent();
        this.inheritedSelector = null;
    }

    get inheritedSelector() {
        return this._inheritedSelector;
    }

    set inheritedSelector(value) {
        this._inheritedSelector = value;
        for (let id in this.children) {
            const theChild = this.children[id].leaf;
            theChild.inheritedSelector = this.selector();
        }
    }

    get selectorToPassToChildren() {
        return this.selector();
    }

    /**
     * The purpose of this method is to export a portable definition that can be
     * later used in order to rebuild the Inicdent at any time
     */
    exportDefinition() {
        const toReturn = {
            ClassName: this.constructor.ClassName,
            plugin_npm_name: this.constructor.plugin_npm_name,
            attrs: this.attrs,
            props: this.props,
            incidents: {}
        }

        for (let id in this.children) {
            const theChild = this.children[id];
            if (theChild.leaf.passive === true) {
                continue;
            }
            toReturn.incidents[id] = {
                id: theChild.id,
                position: theChild.position,
                leaf: theChild.leaf.exportDefinition()
            }
        }

        return toReturn;
    }

    addIncident(descriptiveIncident, position, options = { check: true }) {
        descriptiveIncident.inheritedSelector = this.selectorToPassToChildren;
        if (options.check === true) {
            const initialCheck = super.checkAddition(descriptiveIncident, position);
            if (initialCheck.result === false) {
                descriptiveIncident.inheritedSelector = null;
                return initialCheck;
            }

            /* Check for null or relative selector Incidents with no inherited selector */
            const checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {},
                _CONST._TARGETTYPES._DECISIONAUTHORITY, { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
            if (checkIfBelongsToClip.response === true) { // if the Group belongs on a Clip
                const selectorsCheck = descriptiveIncident.putMessageOnPipe('checkForInvalidSelectors', {}, null, { selfExecute: true, direction: _TREECONST._DIRECTIONS._DOWN });
                if (selectorsCheck.length > 0) {
                    const errors = [];
                    for (let i = 0; i < selectorsCheck.length; i++) {
                        errors.push(selectorsCheck[i].response);
                    }
                    return {
                        result: false,
                        errors: errors
                    }
                }
            }

            // sends the check request to its root, either a headless root or a Descriptive Clip
            const mcCheck = this.putMessageOnPipe('checkAddition', { incident: descriptiveIncident, millisecond: position, parentGroupId: this.id },
                _CONST._TARGETTYPES._DECISIONAUTHORITY, { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
            if (mcCheck.response.result === false) {
                descriptiveIncident.inheritedSelector = null;
                return mcCheck.response;
            }
        }

        // if the passiveAddition flag is true we set the passive flag of the Incident
        // to true before adding it to our Group
        if (this.passiveAddition === true) {
            descriptiveIncident.passive = true;
        }

        const res = this.addChild(descriptiveIncident, position);
        if (res.result === false) {
            descriptiveIncident.inheritedSelector = null;
        }
        return res;
    }

    /**
     * @param input - can either be object or id
     **/
    moveIncident(input, position) {
        let id = input;
        if (typeof input === "object") {
            id = input.id;
        }

        const initialCheck = super.checkEditPosition(id, position);

        if (initialCheck.result === false) {
            return initialCheck;
        }

        const originalPosition = this.getLeafPosition(id);
        const positionDelta = position - originalPosition;
        if (positionDelta === 0) {
            return { result: true };
        }

        const mcCheck = this.putMessageOnPipe('checkMove', { id: id, millisecond: position, positionDelta: positionDelta, parentGroupId: this.id },
            _CONST._TARGETTYPES._DECISIONAUTHORITY, { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
        if (mcCheck.response.result === false) {
            return mcCheck.response;
        }

        const res = this.editPosition(id, position);
        return res;
    }

    removeIncident(input) {
        let id = input;
        if (typeof input === "object") {
            id = input.id;
        }

        const initialCheck = super.checkRemoveChild(id);

        if (initialCheck.result === false) {
            return initialCheck;
        }

        const mcCheck = this.putMessageOnPipe('checkDeletion', { id: id, parentGroupId: this.id },
            _CONST._TARGETTYPES._DECISIONAUTHORITY, { selfExecute: true, direction: _TREECONST._DIRECTIONS._UP });
        if (mcCheck.response.result === false) {
            return mcCheck.response;
        }

        const res = this.removeChild(id);
        return res;
    }


    /*************************** HANDLING METHODS *******************************/
    handleCheckForClip(target, payload) { // eslint-disable-line no-unused-vars
        if (this.hasParent) {
            return this.bypass();
        }
        return false;
    }

    handleCheckAddition(target, payload) { // eslint-disable-line no-unused-vars
        /*
        The DescriptiveGroup handles the checkAddition command which has the UP
        direction. If the DG has a parent it forwards the command to it. If not
        it just returns true, as it is a deadless tree
        */
        if (this.hasParent) {
            return this.bypass();
        }
        return {
            result: true
        }
    }

    handleCheckMove(target, payload) { // eslint-disable-line no-unused-vars
        if (this.hasParent) {
            return this.bypass();
        }

        return {
            result: true
        }
    }

    handleCheckDeletion(target, payload) { // eslint-disable-line no-unused-vars
        if (this.hasParent) {
            return this.bypass();
        }

        return {
            result: true
        }
    }

    handleCheckResize(target, payload) { // eslint-disable-line no-unused-vars
        if (this.hasParent) {
            return this.bypass();
        }

        return {
            result: true
        }
    }

}

module.exports = DescriptiveGroup;
