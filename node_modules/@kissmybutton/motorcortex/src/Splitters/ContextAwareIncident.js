const Leaf = require('../Tree/Leaf');
const incidentFromIngredients = require('../IncidentFromDefinition/incidentFromIngredients');
const getIncidentsByChannel = require('../_decorators/getIncidentsByChannel');
const _CONST = require('../_configuration/_CONST');


class ContextAwareIncident extends Leaf {
    constructor(constructionIngredients, contextData, mcid, attribute) {
        super({
            ...constructionIngredients.props,
            id: attribute !== null ? `${constructionIngredients.incidentId}_${mcid}_${attribute}` : `${constructionIngredients.incidentId}_${mcid}`
        });

        // a property to hold all of the contexts
        this.contexts = {};

        this.constructionIngredients = constructionIngredients;
        this.mcid = mcid;
        this.attribute = attribute;
        // this._duration = constructionIngredients.props.duration;

        this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;
        this.plugin_channel_class = constructionIngredients.Channel;

        this.DescriptiveIncident = constructionIngredients.DescriptiveIncident;

        this.addContext(contextData);

        if (attribute !== null) {
            if (typeof this.constructionIngredients.attrs.animatedAttrs[this.attribute] === 'object') {
                this.originalAnimatedAttributeValue = Object.assign({}, this.constructionIngredients.attrs.animatedAttrs[this.attribute]);
            }
            else {
                this.originalAnimatedAttributeValue = this.constructionIngredients.attrs.animatedAttrs[this.attribute];
            }
        }
    }


    get originalContext() {
        return this.contexts[this.originalContextKey];
    }


    get duration() {
        return super.duration;
    }

    set duration(milliseconds) {
        super.duration = milliseconds;

        for (let context in this.contexts) {
            this.contexts[context].duration = milliseconds;
        }
    }

    addContext(contextData, forceGetContext = false) {
        // if it's the first context to be added then it's the original
        let isTheOriginalContext = false;
        if (Object.keys(this.contexts).length === 0) {
            this.originalContextKey = contextData.clipId;
            this.originalClipContext = contextData.context;
            isTheOriginalContext = true;
        }

        const ingredientsToPass = { ...this.constructionIngredients, context: contextData.context, mcid: this.mcid };
        const whatToAdd = incidentFromIngredients(ingredientsToPass);
        this.contexts[contextData.clipId] = whatToAdd;

        // when we add a new context we must set the inital value of the newly added Incidents
        if (!isTheOriginalContext) {
            this.contexts[contextData.clipId].setInitialValue(this.getInitialValue());
        }

        if (forceGetContext === true) {
            this.contexts[contextData.clipId]._onGetContextOnce();
        }
    }

    handleAddContext(target, payload) {
        this.addContext(payload, true);
        return true;
    }

    @getIncidentsByChannel
    getIncidentsByChannel() {}

    onProgress(fraction, milliseconds, contextId) {
        /* MonoIncidents are totally agnostic about delay, hiatus and repeats.
        CAI is not that's exactly the point where these properties management occurs.
        Having alredy set the duration of the ContextAwareIncident according to
        all of these props, here the CAI decides on the progress that its MonoIncidents
        are to on at the given millisecond and according to the given props.
        */

        // step 1: find the full delay-duration-hiatus duration of one repeat
        const repeatDuration = this.delay + this.props.duration + this.hiatus;
        // step 2.a: find the running repeat and millisecond of this repeat
        let millisecondWithinRepeat = milliseconds % repeatDuration;
        // step 2.b: decide between 0 and 1
        if (milliseconds !== 0 && millisecondWithinRepeat === 0) {
            millisecondWithinRepeat = this.delay + this.props.duration;
        }
        // step 3: find the millisecond of the MonoIncident
        let MI_millisecond = millisecondWithinRepeat - this.delay;
        if (MI_millisecond < 0) {
            MI_millisecond = 0;
        }
        else if (MI_millisecond > this.props.duration) { // if it has stepped into hiatus
            MI_millisecond = this.props.duration;
        }
        const MI_fraction = MI_millisecond / this.props.duration;

        if (contextId === undefined) {
            for (let context in this.contexts) {
                this.contexts[context].onProgress(MI_fraction, MI_millisecond);
            }
            return;
        }

        this.contexts[contextId].onProgress(MI_fraction, MI_millisecond);
    }

    /** METHODS THAT ACT AS "PROXY" TO ALL OF THE INCIDENTS BELONGING TO
     * THE INCIDENTS COLLECTION OF THE CONTEXT AWARE INCIDENT
     **/
    get animatedAttributeValue() {
        return this.constructionIngredients.attrs.animatedAttrs[this.attribute];
    }

    set animatedAttributeValue(value) {
        this.constructionIngredients.attrs.animatedAttrs[this.attribute] = value;
    }

    // massive editing methods that apply the request massively to all of the
    // Incidents of all of the contexts
    gotContext() {
        for (let context in this.contexts) {
            this.contexts[context].gotContext();
        }
    }

    _onGetContextOnce() {
        for (let context in this.contexts) {
            this.contexts[context]._onGetContextOnce();
        }
    }

    lastWish() {
        for (let context in this.contexts) {
            this.contexts[context].lastWish();
        }
    }

    onGetContext() {
        for (let context in this.contexts) {
            this.contexts[context].onGetContext();
        }
    }

    getInitialValue(attribute = null) {
        if (attribute === null) {
            attribute = this.attribute;
        }
        return this.originalContext.getInitialValue();
    }

    get initialValue() {
        return this.getInitialValue();
    }

    get scratchValue() {
        return this.originalContext.scratchValue;
    }

    get pureInitialValues() {
        return this.originalContext.pureInitialValues;
    }

    setInitialValue(value = null, store = true) {
        if (value === null) {
            value = this.getScratchValue();
        }

        for (let context in this.contexts) {
            this.contexts[context].setInitialValue(JSON.parse(JSON.stringify(value)), store);
        }
    }

    getScratchValue(contextId = null) {
        if (contextId === null) {
            const contextsKeys = Object.keys(this.contexts);
            if (Object.prototype.hasOwnProperty.call(this.originalClipContext, 'nonFragmentedContext')) {
                const ingredientsToPass = { ...this.constructionIngredients, context: this.originalClipContext.nonFragmentedContext, mcid: this.mcid };
                const tempIncident = incidentFromIngredients(ingredientsToPass);
                return tempIncident.getScratchValue();
            }
            else if (contextsKeys.length === 1) {
                return this.originalContext.getScratchValue();
            }
            else { // prefer another (not the original) context to provide scratch values
                return this.contexts[contextsKeys[1]].getScratchValue();
            }
        }
        return this.contexts[contextId].getScratchValue();
    }

    setCompoAttrKeyValue(key, value) {
        for (let context in this.contexts) {
            this.contexts[context].attrs.animatedAttrs[this.attribute][key] = value;
            this.contexts[context].lastWish();
            this.contexts[context].onGetContext();
        }
    }

    play(fraction, ms, contextId) {
        return this.contexts[contextId].play(ms);
    }

    stop(contextId) {
        this.contexts[contextId].stop();
    }
}

module.exports = ContextAwareIncident;
